'use client';

const content = `## 컴포넌트를 작게 나누는 것만으로 충분할까?

프론트엔드 개발을 하다 보면 늘 고민하게 되는 것이 책임의 분리  이다. 단일 책임 원칙을 따르기 위해 컴포넌트를 작게 나누지만, 그것만으로 충분할까? 하는 고민이 들었다. 예를 들어, 데이터 패칭은 컴포넌트 내부에서 react-query를 사용해 처리하고, 그 결과를 바로 렌더링에 활용하는 구조를 흔히 사용하는데, 이런 방식을 사용하다보면 다음과 같은 고민이 생긴다. 

* 데이터 가공이 컴포넌트 안에서 일어나 책임이 명확하지 않음
* 같은 가공 로직이 여러 컴포넌트에 흩어질 수 있음
* UI를 위한 데이터와 실제 서버 데이터 간 괴리가 존재함

이런 경험을 하며, 단순히 UI 단에서 컴포넌트를 나누는 것만으로는 구조적인 문제를 해결할 수 없다는 생각이 들었다.
### 서버와의 인터페이스, 그리고 '준비된' 프론트엔드

프론트엔드 개발자는 서버 개발자와 긴밀하게 협업한다. API 요청을 보내고, 그에 따른 응답을 기반으로 동작하기 때문에 매우 자연스러운 흐름이라고 볼 수 있다. 

그런데 실제로 프로젝트를 진행하면서 느꼈던 점은, 서버의 응답 구조가 어느 정도 정해졌다면 이를 바탕으로 프론트엔드 내부에서 사용할 계층을 먼저 정의할 수 있다는 것이다. 예를 들어, 도메인 모델과 DTO 구조를 미리 설계해 두면, 서버에서 응답 형식이 바뀌더라도 그에 대응하는 계층만 수정하면 되기 때문에 UI나 비즈니스 로직은 손대지 않아도 된다.

이러한 구조는 서버 작업이 끝날때까지 기다리지 않고 작업을 할 수 있도록 작업의 병렬성을 높여주고, 유지보수 시에도 매우 큰 장점으로 작용할 수 있다.

최근에는 Next.js, SvelteKit과 같은 풀스택 프레임워크가 대세로 떠오르면서, 프론트와 백엔드의 경계가 점점 더 흐려지고 있다. API 라우트, 서버 액션, SSR/ISR 등 다양한 기능들이 프론트엔드 개발자에게 서버 역할의 일부까지 맡기게 만들고 있다. 이처럼 역할의 경계가 모호해질수록 중요한 건, **결국 데이터가 어디서 왔고, 어떻게 가공되어, 어디서 사용되는지에 대한 명확한 이해다.**

이해가 부족하면 협업 시 "어디서부터 어디까지 내가 책임져야 하는지"조차 헷갈리게 되며, 반대로 흐름을 정확히 알고 있다면, 작업 범위를 능동적으로 제안하거나 조율할 수 있다. 서버와의 인터페이스를 단순히 '요청/응답'으로만 보지 않고, 구조적으로 분리된 계층을 통해 유연하게 설계하고 대처할 수 있어야 한다. 이것이야말로 지금 시대의 프론트엔드 개발자에게 필요한 태도라고 생각한다!

## Next.js 프로젝트 구조 설계

이번에 진행한 프로젝트에서는 Next.js + Supabase 환경에서 다음과 같이 클린 아키텍처 패턴을 적용해 보았다. 프로젝트는 기능(domain) 중심으로 나누고, 그 안에서 application / domain / infra 계층을 구성했다.


domain/repositories
데이터 저장 방식과 무관하게 사용할 수 있는 추상 인터페이스 를 정의한다.



infra/repositories
실제 저장소 호출 구현부. Supabase, Firebase 등 외부 의존성을 여기에 담는다.



application/usecases
유저 행위 단위의 로직을 담당하며, 저장소와 엔티티를 조합해 로직을 실행한다.


application/usecases/dto
유즈케이스 입출력 데이터 구조. 유효성 검사나 변환 등을 담당한다.


## 핵심 원칙: 의존성 역전과 관심사의 분리

![](https://velog.velcdn.com/images/o1011/post/6a8d4b2b-8573-42f4-b232-49e585b1f882/image.png)

클린 아키텍처의 핵심은 다음과 같다. 

1. 관심사의 분리 
각 계층(도메인, 애플리케이션, 인프라 등)은 명확하게 자신의 역할만 수행해야 한다. UI, 데이터 접근, 비즈니스 로직이 섞이지 않고, 변경에 유연하게 대응할 수 있다.

2. 의존성 역전 (Dependency Inversion)
고수준 모듈(핵심 비즈니스 로직)이 저수준 모듈(라이브러리, 프레임워크, DB 등)에 의존하면 안 된다. 반대로, 저수준 모듈이 고수준 모듈에 의존해야 한다. 즉, 핵심 로직은 외부 기술(Supabase, Axios, Firebase 등)에 종속되면 안되며, 외부 의존성은 내부 규칙(인터페이스)에 맞춰 동작해야 한다.

이를 실현하기 위해 사용하는 기법이 **의존성 주입(DI)**이다.

### 의존성 주입이란?

필요한 의존성을 내부에서 생성하지 않고 외부에서 주입받는 방식이다. 쉽게 말하면, "내가 필요한 걸 직접 만들지 않고, 외부에서 제공받는다."

CreateProjectUsecase는 내부적으로 DB나 외부 API를 직접 알지 않는다. 대신, ProjectRepository라는 인터페이스만 알고 있으며, 어떤 구현체가 들어오든 상관하지 않는다. SbProjectRepository는 Supabase에 맞춰 구현된 실제 인프라 계층이다.

이렇게 하면 Supabase를 Firebase로 바꾸더라도, CreateProjectUsecase는 변경할 필요가 없어진다. 


## 클린 아키텍처 도입 후 느낀 점

처음 클린 아키텍처를 적용해보면서 나도 모르게 그 ‘형식’에 집착하게 된 부분이 있었다. "이건 이렇게 나눠야 돼", "이 계층이 있어야 완전해" 같은 강박이 생겼고, 오히려 복잡하게만 느껴지기도 했다. 할수록 ‘이게 과연 실용적인가?’ 라는 회의감도 들었고, 코드가 더 불편해진 느낌이 들 때도 있었다.

그러던 중 아래 글을 읽고 나서 많은 공감이 되었다


> [클린아키텍처 썼는데 왜 프로젝트가 더 더러워지지](https://medium.com/mj-studio/%ED%81%B4%EB%A6%B0%EC%95%84%ED%82%A4%ED%85%8D%EC%B2%98-%EC%8D%BC%EB%8A%94%EB%8D%B0-%EC%99%9C-%ED%94%84%EB%A1%9C%EC%A0%9D%ED%8A%B8%EA%B0%80-%EB%8D%94-%EB%8D%94%EB%9F%AC%EC%9B%8C%EC%A7%80%EC%A7%80-3565aaffca8c)

이 글에서처럼, 형식에만 집착하면 진짜 목적을 잃기 쉽다. 클린 아키텍처의 핵심은 ‘깨끗한 구조’ 그 자체가 아니라, 복잡한 시스템에서도 변경이 용이하고 각 책임이 명확한 구조를 만드는 것이라는 점을 다시금 느꼈다.

결국 중요한 건, 특정 규칙을 맹목적으로 따르는 게 아니라 해당 프로젝트의 상황과 규모에 맞게, 유연하게 적용하는 것이다.
"어떤 데이터를, 어떤 방식으로, 어떤 계층에서 처리할 것인가" 를 명확히 설계하고 그리고 무엇보다, 코드를 설계하는 사람 자신이 **“내가 무엇을 책임지고 있는가”, “이 계층은 왜 존재해야 하는가” 를 분명히 인식하게 해준다는 점이다. **


### 다음 프로젝트에 반영하고 싶은 점

이번 경험을 통해, 다음 프로젝트에서는 단순히 아키텍처 구조만 가져오기보다는 협업과 유연성을 고려한 실제 설계 프로세스에 더 신경 쓰고 싶다. 

✅ 프론트에서 먼저 설계하고 개발할 수 있는 기반 만들기
→ 서버 개발이 병행되지 않더라도, 프론트 개발이 가능한 구조 만들기 (ex. 임시 Mock 데이터 기반)

✅ 도메인 모델과 DTO(전달 객체)를 먼저 설계하기
→ 클라이언트와 서버 간 데이터 흐름을 명확하게 정의하고, 개발 전 커뮤니케이션 비용 줄이기

✅ 서버 응답이 달라져도 프론트 구조를 유지할 수 있게 설계하기
→ API 응답과 프론트 내부 데이터 구조를 분리하여 리팩토링 부담 줄이기

✅ UI용 DTO와 서버용 DTO의 명확한 분리
→ 뷰(View)에 최적화된 데이터와 서버 통신을 위한 데이터는 목적과 책임이 다르므로, 이를 분리해 각자의 역할에 집중할 수 있게 하기
`;

const Test = () => {
  const handlerTest = async () => {
    const response = await fetch('/api/ai', {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
      },
      body: JSON.stringify({ question: content }),
    });

    const result = await response.json();
    console.log(result);
  };

  return (
    <div>
      <button onClick={handlerTest}>test</button>
    </div>
  );
};

export default Test;
